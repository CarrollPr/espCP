<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ESP32 Web Flasher — by Aik Carroll</title>

<style>
:root{--glass-bg: rgba(255,255,255,0.04);--glass-border: rgba(255,255,255,0.06);}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef8;background:linear-gradient(135deg,#0f2027 0%,#203a43 50%,#2c5364 100%);}
.wrap{max-width:1100px;margin:28px auto;padding:20px;background:var(--glass-bg);backdrop-filter:blur(12px) saturate(120%);border-radius:14px;border:1px solid var(--glass-border);box-shadow:0 20px 60px rgba(0,0,0,0.6);}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.h1{font-size:18px;margin:0}
.grid{display:grid;grid-template-columns:360px 1fr;gap:16px}
.panel{padding:12px;border-radius:12px;background:transparent;border:1px solid rgba(255,255,255,0.03)}
label{display:block;font-size:13px;margin-bottom:6px;color:#cfe7ff}
.row{display:flex;gap:8px;align-items:center}
button,select,input{background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.03);color:#eaf6ff;padding:8px 10px;border-radius:8px}
button:disabled{opacity:0.5}
.drop{border:2px dashed rgba(255,255,255,0.03);padding:12px;border-radius:8px;text-align:center;cursor:pointer}
.progress{height:14px;background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden;margin-top:8px}
.progress > i{display:block;height:100%;width:0;background:linear-gradient(90deg,rgba(0,200,255,0.14),rgba(0,255,200,0.08));box-shadow:0 0 12px rgba(0,200,255,0.06) inset}
.terminal{height:320px;overflow:auto;background:rgba(0,0,0,0.26);padding:10px;border-radius:8px;font-family:monospace;font-size:13px;color:#cfe7ff;white-space:pre-wrap}
.footer{text-align:center;margin-top:12px}
.footer small{background:var(--glass-bg);padding:6px 10px;border-radius:8px;border:1px solid var(--glass-border)}
.mobile-banner{display:none;background:#7b1f1f;padding:12px;border-radius:10px;margin-bottom:12px;color:#fff;font-weight:700}
@media(max-width:880px){.grid{grid-template-columns:1fr}.mobile-banner{display:block}}
.small{font-size:13px;color:#c6dff8}
</style>
</head>
<body>
<div class="wrap" role="main">
  <div class="header">
    <div class="h1">ESP32 Web Flasher — esptool-js</div>
    <div class="small">Design: liquid glass · Dark gradient</div>
  </div>

  <div id="mobileBanner" class="mobile-banner">Ваш браузер не поддерживает WebSerial API. Пожалуйста, используйте Chrome или Edge на компьютере.</div>

  <div class="grid">
    <div>
      <div class="panel">
        <label>Подключение</label>
        <div class="row">
          <button id="btnPort">Выбрать порт</button>
          <button id="btnDisconnect" disabled>Отключить</button>
        </div>
        <div style="height:8px"></div>
        <label>Baudrate</label>
        <select id="baud"><option>115200</option><option>230400</option><option selected>460800</option><option>921600</option></select>
        <div style="height:8px"></div>
        <label>Авто-вход в bootloader</label>
        <div class="row">
          <button id="btnAuto" data-on="true">ON</button>
          <div class="small">Использовать RTS/DTR. Если не работает — инструкция ниже.</div>
        </div>

        <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">

        <label>Прошивка (.bin)</label>
        <div id="drop" class="drop">Перетащите .bin или нажмите для выбора</div>
        <input id="file" type="file" accept=".bin" style="display:none" />
        <div id="fileInfo" class="small" style="margin-top:8px">Файл не выбран</div>

        <div style="height:8px"></div>
        <label>Адрес (hex или dec)</label>
        <input id="address" value="0x10000" />

        <div style="height:10px"></div>
        <div class="row">
          <button id="btnFlash" disabled>Прошить</button>
          <button id="btnErase" disabled>Erase chip</button>
        </div>

        <div style="height:10px"></div>
        <label>Advanced</label>
        <div class="small">Chunk size и retries (fallback: 4096)</div>
        <div class="row" style="margin-top:8px">
          <input id="chunk" type="number" value="4096" style="width:120px" />
          <input id="retries" type="number" value="3" style="width:120px" />
        </div>

        <div style="height:10px"></div>
        <div class="small">
          Инструкция если авто не сработал:<br>
          Удерживайте BOOT (GPIO0), нажмите RESET (EN), отпустите RESET, отпустите BOOT.
        </div>
      </div>
    </div>

    <div>
      <div class="panel">
        <label>Прогресс</label>
        <div class="progress"><i id="bar"></i></div>
        <div style="display:flex;justify-content:space-between;margin-top:6px">
          <div id="pct" class="small">0%</div>
          <div id="speed" class="small">— KB/s</div>
        </div>

        <div style="height:12px"></div>
        <label>Терминал (всё выводится сюда)</label>
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <button id="btnClear">Очистить лог</button>
          <button id="btnCopy">Скопировать лог</button>
          <button id="btnSave">Скачать лог</button>
          <div style="flex:1"></div>
          <label class="small"><input type="checkbox" id="debug"/> Debug</label>
        </div>
        <div id="term" class="terminal" aria-live="polite"></div>
      </div>

      <div class="panel" style="margin-top:12px">
        <label>Диагностика esptool-js</label>
        <div id="libInfo" class="small">Загрузка библиотеки...</div>
        <div style="height:10px"></div>
        <div class="footer"><small>by Aik Carroll</small></div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/*
  Полностью рабочий single-file web flasher, best-effort:
  - динамически импортирует esptool-js ESM bundle (jsDelivr +esm)
  - использует ESPLoader API (если экспортировано) или делает адаптер
  - поддерживает Web Serial, RTS/DTR auto boot (если port.setSignals есть)
  - печатает все логи в терминал
  - mobile detection -> banner
*/

const logEl = document.getElementById('term');
const libInfo = document.getElementById('libInfo');
const mobileBanner = document.getElementById('mobileBanner');
const debugCheckbox = document.getElementById('debug');

function now(){ return new Date().toISOString().slice(11,23); }
function log(...args){
  const msg = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
  logEl.textContent += `[${now()}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function dbg(...args){ if (debugCheckbox.checked) log('[DBG]', ...args); }
function setLibInfo(s){ libInfo.textContent = s; }

function isMobile(){ return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent); }
if (isMobile() || !('serial' in navigator)) {
  mobileBanner.style.display = 'block';
} else {
  mobileBanner.style.display = 'none';
}

/* UI refs */
const btnPort = document.getElementById('btnPort');
const btnDisconnect = document.getElementById('btnDisconnect');
const btnAuto = document.getElementById('btnAuto');
const baudEl = document.getElementById('baud');
const drop = document.getElementById('drop');
const fileInput = document.getElementById('file');
const fileInfo = document.getElementById('fileInfo');
const addressEl = document.getElementById('address');
const btnFlash = document.getElementById('btnFlash');
const btnErase = document.getElementById('btnErase');
const chunkEl = document.getElementById('chunk');
const retriesEl = document.getElementById('retries');
const bar = document.getElementById('bar');
const pct = document.getElementById('pct');
const speedEl = document.getElementById('speed');
const btnClear = document.getElementById('btnClear');
const btnCopy = document.getElementById('btnCopy');
const btnSave = document.getElementById('btnSave');
const libInfoDiv = document.getElementById('libInfo');

/* state */
let selectedFile = null;
let port = null;
let esptool = null; // imported module
let ESPLoader = null;
let BrowserTransportClass = null;
let loader = null;
let transport = null;
let connectedBaud = null;

/* attempt dynamic import of esptool-js ESM bundle (jsDelivr +esm preferred) */
const ESM_CANDIDATES = [
  'https://cdn.jsdelivr.net/npm/esptool-js@0.5.7/+esm',
  'https://cdn.jsdelivr.net/npm/esptool-js/+esm',
  // fallback to unpkg as module-ish (may not work in all cases)
  'https://unpkg.com/esptool-js@0.5.7/+esm',
];

async function importEsptool(){
  for (const url of ESM_CANDIDATES){
    try{
      dbg('Attempt import', url);
      const mod = await import(url);
      if (mod){
        log('esptool-js module imported from ' + url);
        setLibInfo('esptool-js imported from ' + url);
        return mod;
      }
    }catch(e){
      dbg('import failed', url, e && e.message ? e.message : e);
    }
  }
  // last resort: try global script via classic CDN (non-module)
  try{
    // try to load classic bundle into DOM and then use global exports
    const classic = document.createElement('script');
    classic.src = 'https://cdn.jsdelivr.net/npm/esptool-js@0.5.7/bundle.js';
    classic.async = true;
    document.head.appendChild(classic);
    await new Promise((r,rej)=>{ classic.onload = r; classic.onerror = ()=>rej(new Error('classic load failed')); setTimeout(()=>rej(new Error('classic load timeout')),4000); });
    log('classic esptool-js bundle loaded from jsDelivr');
    setLibInfo('esptool-js classic bundle loaded');
    // give globals a moment
    await new Promise(r=>setTimeout(r,100));
    // collect likely globals
    const names = Object.keys(window).filter(k=>/ESPLoader|esptool|esptooljs|BrowserSerial/i.test(k));
    dbg('globals after classic load', names);
    return window; // return window so caller can look for exports
  }catch(e){
    dbg('classic bundle load failed', e && e.message ? e.message : e);
  }
  return null;
}

/* build a transport wrapper (if library doesn't provide one) */
function makeWebSerialTransport(p){
  return {
    port: p,
    async open(opts){
      const baud = opts?.baudRate || Number(baudEl.value) || 115200;
      await p.open({ baudRate: baud });
      this.reader = p.readable.getReader();
      this.writer = p.writable.getWriter();
      dbg('transport opened', {baud});
    },
    async close(){
      try{ if (this.reader){ await this.reader.cancel(); this.reader.releaseLock(); this.reader = null; } }catch(e){ dbg('reader cancel', e); }
      try{ if (this.writer){ this.writer.releaseLock(); this.writer=null; } }catch(e){ dbg('writer release', e); }
      try{ await p.close(); }catch(e){ dbg('port close', e); }
      dbg('transport closed');
    },
    async write(buf){
      // expects Uint8Array or ArrayBuffer
      if (this.writer == null) throw new Error('writer not available');
      await this.writer.write(buf instanceof Uint8Array ? buf : new Uint8Array(buf));
    },
    async readChunk(){
      if (!this.reader) throw new Error('reader not available');
      const { value, done } = await this.reader.read();
      if (done) return null;
      return value instanceof Uint8Array ? value : new Uint8Array(value);
    },
    async setSignals(signals){
      if (typeof p.setSignals !== 'function') throw new Error('setSignals not supported');
      await p.setSignals(signals);
    },
    async getInfo(){ return p.getInfo ? p.getInfo() : {}; }
  };
}

/* helper to detect exports in imported module/window */
function detectExports(mod){
  const found = {};
  // ESPLoader
  found.ESPLoader = mod.ESPLoader || mod.default?.ESPLoader || mod.esptool?.ESPLoader || null;
  // Transport (browser)
  found.BrowserTransport = mod.BrowserSerialTransport || mod.WebSerialTransport || mod.Transport?.BrowserSerialTransport || mod.Transport || null;
  // Flash API presence detection
  // many versions export functions named 'writeFlash' or 'flash' on ESPLoader prototype
  return found;
}

/* import and init library on load */
let importResult = null;
(async ()=>{
  if (!('serial' in navigator)){
    setLibInfo('WebSerial API недоступен в этом браузере.');
    log('navigator.serial not found. WebSerial not supported. Use Chrome/Edge.');
    return;
  }
  setLibInfo('Импорт esptool-js...');
  importResult = await importEsptool();
  if (!importResult){
    setLibInfo('Не удалось загрузить esptool-js. Проверьте подключение CDN.');
    log('Не удалось импортировать esptool-js. Смотрите сообщения в терминале.');
    return;
  }
  esptool = importResult;
  const ex = detectExports(esptool === window ? window : esptool);
  ESPLoader = ex.ESPLoader || null;
  BrowserTransportClass = ex.BrowserTransport || null;
  setLibInfo('ESPLoader: ' + (ESPLoader ? 'found' : 'NOT found') + '; BrowserTransport: ' + (BrowserTransportClass ? 'found' : 'NOT found'));
  log('esptool exports detection:', { ESPLoader: !!ESPLoader, BrowserTransport: !!BrowserTransportClass });
  if (!ESPLoader){
    log('WARNING: ESPLoader class not found in module. The page will still attempt to use a transport adapter and raw calls, but full functionality may require specific esptool-js bundle.');
  }
})();

/* UI interactions */
drop.addEventListener('click', ()=> fileInput.click());
drop.addEventListener('dragover', e=>{ e.preventDefault(); drop.style.opacity=0.7; });
drop.addEventListener('dragleave', ()=>{ drop.style.opacity=1; });
drop.addEventListener('drop', e=>{ e.preventDefault(); drop.style.opacity=1; fileChosen(e.dataTransfer.files[0]); });
fileInput.addEventListener('change', ()=> fileChosen(fileInput.files[0]));

function fileChosen(f){
  if (!f) return;
  selectedFile = f;
  fileInfo.textContent = `${f.name} · ${f.size} bytes`;
  computeHash(f).then(h => fileInfo.textContent += ` · SHA1: ${h}`);
  btnFlash.disabled = false;
}

async function computeHash(file){
  try{
    const buf = await file.arrayBuffer();
    const digest = await crypto.subtle.digest('SHA-1', buf);
    return Array.from(new Uint8Array(digest)).map(b=>b.toString(16).padStart(2,'0')).join('');
  }catch(e){ return '—'; }
}

/* connect / prepare transport / loader */

btnPort.onclick = async ()=>{
  try{
    log('Запрос порта...');
    const filters = [
      { usbVendorId: 0x10C4 }, // CP210x
      { usbVendorId: 0x1A86 }, // CH340
      { usbVendorId: 0x0403 }, // FTDI
      { usbVendorId: 0x067B }  // Prolific
    ];
    port = await navigator.serial.requestPort({ filters });
    log('Порт выбран. Инфо: ' + JSON.stringify(port.getInfo ? await port.getInfo() : {}));
    // create transport wrapper (not opening here yet)
    transport = makeWebSerialTransport(port);
    btnDisconnect.disabled = false;
    btnPort.disabled = true;
    btnErase.disabled = false;
    btnFlash.disabled = selectedFile ? false : true;
  }catch(e){ log('Ошибка select port: ' + (e && e.message ? e.message : e)); }
};

btnDisconnect.onclick = async ()=>{
  try{
    if (loader && loader.disconnect) {
      try{ await loader.disconnect(); } catch(e){ dbg('loader.disconnect err', e); }
    }
    if (transport) {
      try{ await transport.close(); } catch(e){ dbg('transport close err', e); }
    }
  }catch(e){ dbg('disconnect err', e); }
  port = null; loader = null; transport = null;
  btnPort.disabled = false; btnDisconnect.disabled = true; btnFlash.disabled = true; btnErase.disabled = true;
  log('Отключено.');
};

btnAuto.onclick = ()=> {
  const on = btnAuto.getAttribute('data-on') !== 'true';
  btnAuto.setAttribute('data-on', on ? 'true' : 'false');
  btnAuto.textContent = on ? 'ON' : 'OFF';
};

/* low-level auto-enter bootloader using port.setSignals when present */
async function autoEnterBootloaderUsingPort(p){
  if (!p) throw new Error('No port');
  if (typeof p.setSignals !== 'function') throw new Error('setSignals not supported');
  const delay = ms => new Promise(r=>setTimeout(r,ms));
  // sequence taken from esptool behaviour (common wiring)
  try{
    await p.setSignals({ dataTerminalReady: true, requestToSend: true });
    await delay(20);
    await p.setSignals({ dataTerminalReady: false, requestToSend: false });
    await delay(120);
    await p.setSignals({ dataTerminalReady: false, requestToSend: true });
    await delay(50);
    await p.setSignals({ dataTerminalReady: true, requestToSend: true });
    await delay(50);
    log('Auto-enter bootloader sequence executed (signals toggled).');
  }catch(e){
    dbg('autoEnter error', e);
    throw e;
  }
}

/* create and connect ESPLoader (if available) or fallback to transport-only */
async function prepareLoaderAndConnect(){
  if (!transport) throw new Error('transport missing');
  const baud = Number(baudEl.value) || 115200;
  // open transport
  try{
    await transport.open({ baudRate: baud });
    connectedBaud = baud;
    log('Transport opened at ' + baud);
  }catch(e){
    throw new Error('Transport open failed: ' + (e && e.message ? e.message : e));
  }

  // If ESPLoader class available, instantiate
  if (ESPLoader){
    try{
      // prefer to use BrowserTransport class if library exposes it
      if (BrowserTransportClass){
        dbg('Library BrowserTransport class present. Creating instance.');
        try{
          // Some bundles export BrowserSerialTransport as constructor taking native port
          // try both: new BrowserTransportClass(port) or new BrowserTransportClass(transport)
          try{
            transport = new BrowserTransportClass(port);
          }catch(e1){
            try{ transport = new BrowserTransportClass(transport); }catch(e2){ dbg('BrowserTransport ctor alternatives failed', e1, e2); }
          }
        }catch(e){ dbg('BrowserTransport init fail', e); }
      }
      // create loader
      // ESPLoader expects { transport, baudrate, terminal? } per docs
      loader = new ESPLoader({ transport, baudrate: connectedBaud, terminal: { writeLine: s=>log(s), write: s=>log(s) } });
      if (loader.connect) {
        log('Attempting loader.connect() ...');
        await loader.connect();
        log('loader.connect() OK');
      } else {
        log('loader.connect() not found; continuing without connect() call');
      }
      return;
    }catch(e){
      dbg('ESPLoader instantiation failed:', e);
      throw new Error('ESPLoader init failed: ' + (e && e.message ? e.message : e));
    }
  } else {
    log('ESPLoader class not found in imported module. Will try to proceed with transport-only methods if possible.');
    return;
  }
}

/* Flash process using loader.writeFlash or fallback attempts */
async function doFlash(){
  if (!selectedFile) throw new Error('No file selected');
  if (!transport) throw new Error('No transport/port');
  // optional auto-enter
  if (btnAuto.getAttribute('data-on') === 'true'){
    try{
      await autoEnterBootloaderUsingPort(port);
    }catch(e){
      log('Auto-enter failed: ' + (e && e.message ? e.message : e));
      log('Попробуйте выполнить ручной вход в bootloader.');
    }
  }

  // prepare loader and transport
  await prepareLoaderAndConnect();

  // prepare binary and options
  const addrStr = addressEl.value.trim();
  const addr = addrStr.startsWith('0x') ? Number(addrStr) : parseInt(addrStr, 10);
  if (Number.isNaN(addr)) throw new Error('Invalid address');

  const arrayBuffer = await selectedFile.arrayBuffer();
  const data = new Uint8Array(arrayBuffer);

  // Try to call loader.writeFlash with FlashOptions if available
  // The API across versions differs, so try common method names and shapes
  const files = [{ address: addr, data }];

  // progress state
  let start = Date.now();
  function updateProgress(written, total){
    const pctv = total ? (written/total*100) : 0;
    bar.style.width = pctv + '%';
    pct.textContent = Math.round(pctv) + '%';
    const elapsed = (Date.now()-start)/1000;
    const kb = Math.round((written/1024)/(elapsed||1));
    speedEl.textContent = kb + ' KB/s';
  }

  // prefer loader.writeFlash if exists
  if (loader && typeof loader.writeFlash === 'function'){
    log('Using loader.writeFlash API');
    const opts = {
      flash_mode: 'dio',
      flash_freq: '40m',
      flash_size: 'detect',
      reportProgress: (fileIndex, written, total) => {
        dbg('reportProgress', fileIndex, written, total);
        updateProgress(written, total);
        log(`Writing ${Math.round(written/1024)} KB / ${Math.round(total/1024)} KB`);
      },
      // some versions use onProgress
      onProgress: (fileIndex, written, total) => {
        updateProgress(written, total); dbg('onProgress', fileIndex, written, total);
      }
    };
    try{
      await loader.writeFlash(files, opts);
      log('writeFlash completed');
      // verify if API present
      if (typeof loader.verifyFlash === 'function'){
        log('Starting verifyFlash...');
        await loader.verifyFlash(files);
        log('verifyFlash OK');
      }else if (typeof loader.verify === 'function'){
        log('Starting verify...');
        await loader.verify(files);
        log('verify OK');
      }else{
        log('Verify API not found; skipping verify.');
      }
    }catch(e){
      throw new Error('writeFlash failed: ' + (e && e.message ? e.message : e));
    }
  } else if (loader && typeof loader.write === 'function' && typeof loader.command === 'function'){
    // lower-level fallback: attempt to use command/write sequence — advanced usage
    log('loader.writeFlash not available; loader has low-level write/command APIs. Attempting fallback (may fail).');
    // Not implementing full protocol here — full implementation is non-trivial.
    throw new Error('Fallback low-level flashing not implemented. Use proper esptool-js bundle exposing writeFlash.');
  } else {
    throw new Error('No flashing API available in loaded esptool-js. Use bundle that exports ESPLoader.writeFlash.');
  }

  // Attempt soft reset/run user code if API present
  try{
    if (loader && typeof loader.run === 'function'){ await loader.run(); log('run() executed'); }
    else if (loader && typeof loader.softReset === 'function'){ await loader.softReset(); log('softReset() executed'); }
    else { log('No run/softReset API available. Please reset the board manually.'); }
  }catch(e){ dbg('run/softReset failed', e); }

  updateProgress(1,1);
}

/* erase function */
async function doErase(){
  if (!transport) throw new Error('No transport');
  await prepareLoaderAndConnect();
  if (loader && typeof loader.eraseChip === 'function'){
    log('Erasing chip...');
    await loader.eraseChip();
    log('Erase complete.');
  } else {
    throw new Error('eraseChip API not available in this esptool-js build.');
  }
}

/* UI bindings for actions */
btnFlash.onclick = async ()=>{
  try{
    if (!selectedFile) { log('Файл не выбран'); return; }
    btnFlash.disabled = true;
    await doFlash();
  }catch(e){
    log('Ошибка: ' + (e && e.message ? e.message : e));
  } finally { btnFlash.disabled = false; }
};

btnErase.onclick = async ()=>{
  try{
    if (!confirm('Подтвердите полное стирание флеша (erase_chip). Продолжить?')) return;
    btnErase.disabled = true;
    await doErase();
  }catch(e){
    log('Erase error: ' + (e && e.message ? e.message : e));
  } finally { btnErase.disabled = false; }
};

btnClear.onclick = ()=> logEl.textContent = '';
btnCopy.onclick = async ()=> { try{ await navigator.clipboard.writeText(logEl.textContent); log('Лог скопирован в буфер обмена'); }catch(e){ log('Copy failed: ' + e); } };
btnSave.onclick = ()=> {
  const blob = new Blob([logEl.textContent], { type:'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'esptool-log.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
};

btnPort.addEventListener('click', async ()=> {
  try{
    log('Requesting port...');
    const filters = [ /* recommended filters, keep optional */ { usbVendorId: 0x10C4 }, { usbVendorId: 0x1A86 }, { usbVendorId: 0x0403 }, { usbVendorId: 0x067B } ];
    port = await navigator.serial.requestPort({ filters });
    log('Port selected: ' + JSON.stringify(port.getInfo ? await port.getInfo() : {}));
    transport = makeWebSerialTransport(port);
    btnPort.disabled = true; btnDisconnect.disabled = false; btnErase.disabled = false;
    btnFlash.disabled = selectedFile ? false : true;
  }catch(e){ log('Port select error: ' + (e && e.message ? e.message : e)); }
});

btnDisconnect.addEventListener('click', async ()=> {
  try{
    if (loader && typeof loader.disconnect === 'function') { await loader.disconnect(); }
    if (transport) { await transport.close(); }
  }catch(e){ dbg('disconnect error', e); }
  port = null; loader = null; transport = null;
  btnPort.disabled = false; btnDisconnect.disabled = true; btnFlash.disabled = true; btnErase.disabled = true;
  log('Disconnected');
});

/* file UI */
function fileChosenEvent(f){
  if (!f) return;
  selectedFile = f;
  fileInfo.textContent = `${f.name} · ${f.size} bytes`;
  computeSHA1(f).then(h => fileInfo.textContent += ` · SHA1:${h}`);
  btnFlash.disabled = false;
}
fileInput.addEventListener('change', ()=> fileChosenEvent(fileInput.files[0]));
function computeSHA1(file){ return file.arrayBuffer().then(buf => crypto.subtle.digest('SHA-1', buf)).then(d=>Array.from(new Uint8Array(d)).map(b=>b.toString(16).padStart(2,'0')).join('')).catch(()=>'-'); }

/* show exported keys helper */
function showWindowExports(){
  const keys = Object.keys(window).filter(k=>/esptool|ESPLoader|BrowserSerial|Transport/i.test(k));
  dbg('Window exports sample:', keys);
  log('Window global keys (sample): ' + JSON.stringify(keys.slice(0,40)));
}

/* on load diagnostics */
(async ()=> {
  dbg('Starting diagnostics...');
  showWindowExports();
  // if esptool module loaded earlier, expose info
  if (typeof ESPLoader === 'function') setLibInfo('ESPLoader class detected');
  else setLibInfo('ESPLoader not detected yet. The page will attempt to import esptool-js via ESM. If not found, load a bundle that exports ESPLoader.writeFlash.');
})();

</script>
</body>
</html>
