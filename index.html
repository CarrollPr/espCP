<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Web Flasher</title>
    <meta name="description" content="Flash ESP32 firmware directly from your browser using Web Serial API">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            min-height: 100vh;
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.04);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #64b5f6, #42a5f5, #2196f3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
        }

        .banner {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            color: #ffb74d;
            font-size: 1.1rem;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #64b5f6;
            border-bottom: 1px solid rgba(100, 181, 246, 0.3);
            padding-bottom: 5px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        input, select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #ffffff;
            padding: 10px 15px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #64b5f6;
            box-shadow: 0 0 0 2px rgba(100, 181, 246, 0.2);
        }

        button {
            cursor: pointer;
            font-weight: 500;
            min-width: 120px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background: linear-gradient(45deg, #2196f3, #21cbf3);
            border: none;
        }

        .btn-danger {
            background: linear-gradient(45deg, #f44336, #ff6b6b);
            border: none;
        }

        .btn-success {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: none;
        }

        .progress-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-text {
            text-align: center;
            margin-top: 5px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }

        .terminal {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .terminal-controls {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
        }

        .file-drop {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-drop:hover,
        .file-drop.dragover {
            border-color: #64b5f6;
            background: rgba(100, 181, 246, 0.1);
        }

        .file-list {
            margin-top: 15px;
        }

        .file-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: 500;
        }

        .status.info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid rgba(33, 150, 243, 0.3);
            color: #64b5f6;
        }

        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.3);
            color: #81c784;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.3);
            color: #e57373;
        }

        .footer {
            text-align: center;
            margin-top: auto;
            padding: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        @media (max-width: 768px) {
            .form-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 10px;
            }
            
            .glass-panel {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
<!--
README: ESP32 Web Flasher
=========================

CDN Used: https://cdn.jsdelivr.net/npm/esptool-js@0.5.7/+esm
Fallback: https://cdn.jsdelivr.net/npm/esptool-js@0.5.7/bundle.js

Testing Checklist:
1. Open in Chrome/Edge on desktop with HTTPS
2. Select ESP32 port (CP210x/CH340)
3. Load .bin file and flash to 0x10000
4. Test auto-boot and manual bootloader entry
5. Verify mobile banner shows on mobile browsers
6. Test error handling with disconnected device

References:
- esptool-js GitHub: https://github.com/espressif/esptool-js
- API docs: https://espressif.github.io/esptool-js/
- Example flasher: https://esptool.spacehuhn.com/
-->

<div class="container">
    <div class="header">
        <h1>ESP32 Web Flasher</h1>
        <p>Flash firmware directly from your browser using Web Serial API</p>
    </div>

    <div id="unsupported-banner" class="banner" style="display: none;">
        Ваш браузер не поддерживает WebSerial API. Пожалуйста, используйте Chrome или Edge на компьютере.
    </div>

    <div id="https-warning" class="banner" style="display: none;">
        WebSerial требует secure context (HTTPS или localhost).
    </div>

    <div class="glass-panel">
        <div class="section">
            <h3 class="section-title">Connection</h3>
            <div class="form-row">
                <button id="select-port" class="btn-primary">Select Port</button>
                <button id="connect-btn" class="btn-success" disabled>Connect</button>
                <button id="disconnect-btn" class="btn-danger" disabled>Disconnect</button>
                <div class="form-group">
                    <label for="baud-rate">Baud Rate:</label>
                    <select id="baud-rate">
                        <option value="115200">115200</option>
                        <option value="230400">230400</option>
                        <option value="460800">460800</option>
                        <option value="921600" selected>921600</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="auto-boot" checked>
                    <label for="auto-boot">Auto-boot</label>
                </div>
            </div>
            <div id="port-info" class="status info" style="display: none;"></div>
        </div>

        <div class="section">
            <h3 class="section-title">Firmware Files</h3>
            <div class="file-drop" id="file-drop">
                <p>Drag & drop .bin files here or click to select</p>
                <input type="file" id="file-input" accept=".bin" multiple style="display: none;">
            </div>
            <div id="file-list" class="file-list"></div>
        </div>

        <div class="section">
            <h3 class="section-title">Flash Options</h3>
            <div class="form-row">
                <div class="form-group">
                    <label for="address">Address (hex):</label>
                    <input type="text" id="address" value="0x10000" placeholder="0x10000">
                </div>
                <div class="form-group">
                    <label for="chunk-size">Chunk Size:</label>
                    <select id="chunk-size">
                        <option value="4096">4096</option>
                        <option value="8192" selected>8192</option>
                        <option value="16384">16384</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="verify-flash" checked>
                    <label for="verify-flash">Verify after flash</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="erase-chip">
                    <label for="erase-chip">Erase entire chip</label>
                </div>
            </div>
            
            <div class="form-row">
                <button id="flash-btn" class="btn-primary" disabled>Flash</button>
                <button id="erase-btn" class="btn-danger" disabled>Erase Flash</button>
                <button id="reset-btn" class="btn-success" disabled>Reset Device</button>
            </div>

            <div id="progress-container" style="display: none;">
                <div class="progress-container">
                    <div id="progress-bar" class="progress-bar"></div>
                </div>
                <div id="progress-text" class="progress-text">0%</div>
            </div>
        </div>

        <div class="section">
            <h3 class="section-title">Terminal</h3>
            <div class="terminal-controls">
                <button id="clear-terminal">Clear</button>
                <button id="copy-terminal">Copy Log</button>
                <button id="download-log">Download Log</button>
                <div class="checkbox-group">
                    <input type="checkbox" id="debug-mode">
                    <label for="debug-mode">Debug Mode</label>
                </div>
            </div>
            <div id="terminal" class="terminal"></div>
        </div>
    </div>

    <div class="footer">
        by Aik Carroll
    </div>
</div>

<script type="module">
let port = null;
let loader = null;
let terminal = null;
let files = [];
let logData = [];
let isConnected = false;

// Check browser support
function checkSupport() {
    const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';
    const hasSerial = 'serial' in navigator;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    if (!isSecure) {
        document.getElementById('https-warning').style.display = 'block';
        return false;
    }

    if (!hasSerial || isMobile) {
        document.getElementById('unsupported-banner').style.display = 'block';
        return false;
    }

    return true;
}

// Terminal functions
function createTerminal() {
    return {
        write: (text) => {
            const timestamp = new Date().toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            });
            
            const line = `[${timestamp}] ${text}`;
            logData.push(line);
            
            const terminalEl = document.getElementById('terminal');
            const div = document.createElement('div');
            div.textContent = line;
            terminalEl.appendChild(div);
            terminalEl.scrollTop = terminalEl.scrollHeight;
        },
        writeLine: (text) => {
            terminal.write(text + '\n');
        },
        clean: () => {
            document.getElementById('terminal').innerHTML = '';
            logData = [];
        }
    };
}

// Import esptool-js
async function loadESPTool() {
    terminal.writeLine('INFO Loading esptool-js...');
    
    try {
        // Try ESM import first
        terminal.writeLine('DEBUG Attempting ESM import from CDN...');
        const module = await import('https://cdn.jsdelivr.net/npm/esptool-js@0.5.7/+esm');
        
        terminal.writeLine('DEBUG Module exports: ' + Object.keys(module).join(', '));
        
        if (module.ESPLoader) {
            terminal.writeLine('INFO ESPLoader found in ESM module');
            return module;
        }
        
        throw new Error('ESPLoader not found in ESM module');
        
    } catch (error) {
        terminal.writeLine('ERROR ESM import failed: ' + error.message);
        terminal.writeLine('INFO Falling back to classic bundle...');
        
        try {
            // Load classic bundle
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/esptool-js@0.5.7/bundle.js';
            
            await new Promise((resolve, reject) => {
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
            
            terminal.writeLine('DEBUG Window exports: ' + Object.keys(window).filter(k => k.includes('ESP')).join(', '));
            
            if (window.ESPLoader) {
                terminal.writeLine('INFO ESPLoader found in global scope');
                return window;
            }
            
            throw new Error('ESPLoader not found in bundle');
            
        } catch (bundleError) {
            terminal.writeLine('ERROR Bundle load failed: ' + bundleError.message);
            terminal.writeLine('ERROR Available window keys: ' + Object.keys(window).join(', '));
            throw new Error('Failed to load esptool-js. Try using a different CDN build or check the espressif/esptool-js repository for latest releases.');
        }
    }
}

// WebSerial Transport Adapter
class WebSerialTransportAdapter {
    constructor(port) {
        this.port = port;
        this.reader = null;
        this.writer = null;
    }

    async open(options = {}) {
        const baudRate = options.baudRate || 115200;
        await this.port.open({ baudRate });
        this.reader = this.port.readable.getReader();
        this.writer = this.port.writable.getWriter();
        terminal.writeLine(`INFO Port opened at ${baudRate} baud`);
    }

    async close() {
        if (this.reader) {
            try { await this.reader.cancel(); } catch(_) {}
            this.reader.releaseLock();
            this.reader = null;
        }
        if (this.writer) {
            this.writer.releaseLock();
            this.writer = null;
        }
        if (this.port) {
            try { await this.port.close(); } catch(_) {}
        }
        terminal.writeLine('INFO Port closed');
    }

    async write(data) {
        if (!this.writer) throw new Error('Port not open for writing');
        await this.writer.write(data);
        if (document.getElementById('debug-mode').checked) {
            terminal.writeLine('DEBUG TX: ' + Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' '));
        }
    }

    async read(timeout = 3000) {
        if (!this.reader) throw new Error('Port not open for reading');
        
        const readPromise = this.reader.read();
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Read timeout')), timeout)
        );
        
        try {
            const result = await Promise.race([readPromise, timeoutPromise]);
            
            if (result.done) {
                throw new Error('Port closed');
            }
            
            if (document.getElementById('debug-mode').checked) {
                terminal.writeLine('DEBUG RX: ' + Array.from(result.value).map(b => b.toString(16).padStart(2, '0')).join(' '));
            }
            
            return result.value;
        } catch(e) {
            // cancel pending read so stream won't hang
            try { await this.reader.cancel(); } catch(_) {}
            throw e;
        }
    }

    async setSignals(signals) {
        if (this.port.setSignals) {
            await this.port.setSignals(signals);
            if (document.getElementById('debug-mode').checked) {
                terminal.writeLine(`DEBUG Signals: DTR=${signals.dataTerminalReady}, RTS=${signals.requestToSend}`);
            }
        }
    }

    getInfo() {
        return this.port.getInfo();
    }
}

// Auto-enter bootloader
async function autoEnterBootloader(port) {
    if (!port.setSignals) {
        terminal.writeLine('ERROR Auto-boot not supported by this port');
        return false;
    }

    try {
        terminal.writeLine('INFO Attempting auto-enter bootloader...');
        
        await port.setSignals({ dataTerminalReady: true, requestToSend: true });
        await new Promise(resolve => setTimeout(resolve, 20));
        
        await port.setSignals({ dataTerminalReady: false, requestToSend: false });
        await new Promise(resolve => setTimeout(resolve, 120));
        
        await port.setSignals({ dataTerminalReady: false, requestToSend: true });
        await new Promise(resolve => setTimeout(resolve, 50));
        
        await port.setSignals({ dataTerminalReady: true, requestToSend: true });
        await new Promise(resolve => setTimeout(resolve, 50));
        
        terminal.writeLine('INFO Auto-boot sequence completed');
        return true;
        
    } catch (error) {
        terminal.writeLine('ERROR Auto-boot failed: ' + error.message);
        return false;
    }
}

// Update progress
function updateProgress(percentage, speed = '', eta = '') {
    const progressBar = document.getElementById('progress-bar');
    const progressText = document.getElementById('progress-text');
    
    progressBar.style.width = percentage + '%';
    progressText.textContent = `${percentage}% ${speed} ${eta}`;
}

// File handling
function handleFiles(fileList) {
    Array.from(fileList).forEach((file, index) => {
        if (!file.name.endsWith('.bin')) {
            terminal.writeLine('ERROR Only .bin files are supported: ' + file.name);
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            const data = new Uint8Array(e.target.result);
            
            // Use predefined addresses to avoid conflicts
            const defaultAddrs = [0x1000, 0x8000, 0x10000];
            const fileObj = {
                name: file.name,
                data: data,
                address: defaultAddrs[files.length] ?? (0x10000 + files.length * 0x10000)
            };
            
            files.push(fileObj);
            
            // Calculate SHA-1
            crypto.subtle.digest('SHA-1', data).then(hashBuffer => {
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                terminal.writeLine(`INFO Loaded ${file.name} (${data.length} bytes) at 0x${fileObj.address.toString(16)}`);
                renderFileList();
                updateUIState();
            });
        };
        reader.readAsArrayBuffer(file);
    });
}

function renderFileList() {
    const fileListEl = document.getElementById('file-list');
    fileListEl.innerHTML = '';
    
    files.forEach((file, index) => {
        const fileDiv = document.createElement('div');
        fileDiv.className = 'file-item';
        fileDiv.dataset.index = index;
        
        fileDiv.innerHTML = `
            <div>
                <strong>${file.name}</strong><br>
                Size: ${file.data.length} bytes
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <input type="text" value="0x${file.address.toString(16)}" 
                       style="width: 100px;" class="address-input">
                <button class="remove-btn">Remove</button>
            </div>
        `;
        
        // Add event listeners
        const addressInput = fileDiv.querySelector('.address-input');
        addressInput.addEventListener('change', (e) => {
            updateFileAddress(index, e.target.value);
        });
        
        const removeBtn = fileDiv.querySelector('.remove-btn');
        removeBtn.addEventListener('click', () => {
            removeFile(index);
        });
        
        fileListEl.appendChild(fileDiv);
    });
}

function updateUIState() {
    document.getElementById('flash-btn').disabled = files.length === 0 || !isConnected;
}

function updateFileAddress(index, value) {
    const address = parseInt(value, value.startsWith('0x') ? 16 : 10);
    if (!isNaN(address) && files[index]) {
        files[index].address = address;
        terminal.writeLine(`INFO Updated ${files[index].name} address to 0x${address.toString(16)}`);
    }
}

function removeFile(index) {
    if (files[index]) {
        const fileName = files[index].name;
        files.splice(index, 1);
        terminal.writeLine(`INFO Removed ${fileName}`);
        renderFileList();
        updateUIState();
    }
}

// Initialize
async function init() {
    if (!checkSupport()) return;

    terminal = createTerminal();
    terminal.writeLine('INFO ESP32 Web Flasher initialized');

    try {
        const espModule = await loadESPTool();
        
        // Enhanced API detection with fallbacks
        const mod = espModule === window ? window : espModule;
        const ESPLoader = mod.ESPLoader || mod.ESPLoaderBrowser || mod.default?.ESPLoader || mod.default || null;
        
        if (!ESPLoader) {
            throw new Error('ESPLoader not found. Available exports: ' + Object.keys(mod).join(', '));
        }
        
        // Create adapter for different method names
        if (ESPLoader.prototype && !ESPLoader.prototype.writeFlash) {
            if (typeof ESPLoader.prototype.write_flash === 'function') {
                ESPLoader.prototype.writeFlash = ESPLoader.prototype.write_flash;
            }
            if (typeof ESPLoader.prototype.flash === 'function') {
                ESPLoader.prototype.writeFlash = ESPLoader.prototype.flash;
            }
        }
        
        window.espModule = { ...espModule, ESPLoader };
        terminal.writeLine('INFO esptool-js loaded successfully');
        terminal.writeLine('DEBUG Available methods: ' + Object.getOwnPropertyNames(ESPLoader.prototype).filter(m => m.includes('flash') || m.includes('erase') || m.includes('write')).join(', '));
    } catch (error) {
        terminal.writeLine('ERROR ' + error.message);
        return;
    }

    // Event listeners
    document.getElementById('select-port').addEventListener('click', async () => {
        try {
            const filters = [
                { usbVendorId: 0x10C4 }, // CP210x
                { usbVendorId: 0x1A86 }, // CH340
                { usbVendorId: 0x0403 }, // FTDI
                { usbVendorId: 0x067B }  // Prolific
            ];
            
            port = await navigator.serial.requestPort({ filters });
            const info = port.getInfo();
            
            document.getElementById('port-info').style.display = 'block';
            document.getElementById('port-info').textContent = 
                `Port selected: VID:${info.usbVendorId?.toString(16)} PID:${info.usbProductId?.toString(16)}`;
            document.getElementById('connect-btn').disabled = false;
            
            terminal.writeLine(`INFO Port selected: VID:${info.usbVendorId?.toString(16)} PID:${info.usbProductId?.toString(16)}`);
        } catch (error) {
            terminal.writeLine('ERROR Port selection failed: ' + error.message);
        }
    });

    document.getElementById('connect-btn').addEventListener('click', async () => {
        if (!port || !window.espModule) return;

        try {
            terminal.writeLine('INFO Подключение...');
            
            const baudRate = parseInt(document.getElementById('baud-rate').value);
            const transport = new WebSerialTransportAdapter(port);
            
            await transport.open({ baudRate });
            
            // Auto-boot if enabled
            if (document.getElementById('auto-boot').checked) {
                const bootSuccess = await autoEnterBootloader(port);
                if (!bootSuccess) {
                    terminal.writeLine('WARNING Авто-вход в bootloader не сработал. Удерживайте BOOT (GPIO0), нажмите RESET (EN), отпустите RESET, отпустите BOOT.');
                }
            }

            loader = new window.espModule.ESPLoader({
                transport: transport,
                baudrate: baudRate,
                terminal: terminal
            });

            await loader.connect();
            terminal.writeLine('INFO Sync...');
            
            if (loader.sync) await loader.sync();
            if (loader.detectChip) {
                const chip = await loader.detectChip();
                terminal.writeLine(`INFO Detected chip: ${chip}`);
            }

            isConnected = true;
            document.getElementById('connect-btn').disabled = true;
            document.getElementById('disconnect-btn').disabled = false;
            document.getElementById('erase-btn').disabled = false;
            document.getElementById('reset-btn').disabled = false;
            updateUIState();
            
            terminal.writeLine('SUCCESS Connected to ESP32');
            
        } catch (error) {
            terminal.writeLine('ERROR Connection failed: ' + error.message);
            if (error.message.includes('Timed out waiting for packet header')) {
                terminal.writeLine('WARNING Плата не в bootloader. Выполните ручной вход: Удерживайте BOOT (GPIO0), нажмите RESET (EN), отпустите RESET, отпустите BOOT');
            }
        }
    });

    document.getElementById('disconnect-btn').addEventListener('click', async () => {
        try {
            if (loader && loader.transport) {
                await loader.transport.close();
            }
            
            isConnected = false;
            loader = null;
            document.getElementById('connect-btn').disabled = false;
            document.getElementById('disconnect-btn').disabled = true;
            document.getElementById('erase-btn').disabled = true;
            document.getElementById('reset-btn').disabled = true;
            updateUIState();
            
            terminal.writeLine('INFO Disconnected');
        } catch (error) {
            terminal.writeLine('ERROR Disconnect failed: ' + error.message);
        }
    });

    document.getElementById('flash-btn').addEventListener('click', async () => {
        if (!loader || files.length === 0) return;

        try {
            document.getElementById('progress-container').style.display = 'block';
            document.getElementById('flash-btn').disabled = true;
            
            const eraseChip = document.getElementById('erase-chip').checked;
            const verifyFlash = document.getElementById('verify-flash').checked;
            const chunkSize = parseInt(document.getElementById('chunk-size').value);

            if (eraseChip) {
                terminal.writeLine('INFO Erase...');
                if (loader.eraseFlash) {
                    await loader.eraseFlash();
                }
            }

            terminal.writeLine('INFO Starting flash...');
            
            const flashFiles = files.map(f => ({
                address: f.address,
                data: f.data
            }));

            let totalSize = files.reduce((sum, f) => sum + f.data.length, 0);
            let written = 0;
            const startTime = Date.now();

            const options = {
                chunkSize: chunkSize,
                reportProgress: (fileIndex, bytesWritten, totalBytes) => {
                    const currentFile = files[fileIndex];
                    const globalProgress = Math.round((written + bytesWritten) / totalSize * 100);
                    
                    const elapsed = (Date.now() - startTime) / 1000;
                    const speed = Math.round((written + bytesWritten) / elapsed / 1024);
                    const eta = elapsed > 0 ? Math.round((totalSize - written - bytesWritten) / ((written + bytesWritten) / elapsed)) : 0;
                    
                    updateProgress(globalProgress, `${speed} KB/s`, `ETA: ${eta}s`);
                    
                    if (bytesWritten === totalBytes) {
                        written += totalBytes;
                        terminal.writeLine(`INFO Completed ${currentFile.name}`);
                    }
                }
            };

            if (loader.writeFlash) {
                await loader.writeFlash(flashFiles, options);
            } else {
                throw new Error('writeFlash method not available. Поменяйте CDN на сборку, экспортирующую ESPLoader.writeFlash, либо используйте репозиторий espressif/esptool-js');
            }

            if (verifyFlash && loader.verifyFlash) {
                terminal.writeLine('INFO Verify...');
                await loader.verifyFlash(flashFiles);
            }

            updateProgress(100, 'Complete', '');
            terminal.writeLine('SUCCESS Готово — устройство запущено.');
            
        } catch (error) {
            terminal.writeLine('ERROR Flash failed: ' + error.message);
        } finally {
            document.getElementById('flash-btn').disabled = false;
        }
    });

    document.getElementById('erase-btn').addEventListener('click', async () => {
        if (!loader) return;

        try {
            terminal.writeLine('INFO Erasing flash...');
            if (loader.eraseFlash) {
                await loader.eraseFlash();
                terminal.writeLine('SUCCESS Flash erased');
            } else {
                terminal.writeLine('ERROR Erase method not available');
            }
        } catch (error) {
            terminal.writeLine('ERROR Erase failed: ' + error.message);
        }
    });

    document.getElementById('reset-btn').addEventListener('click', async () => {
        if (!loader) return;

        try {
            terminal.writeLine('INFO Resetting device...');
            if (loader.hardReset) {
                await loader.hardReset();
                terminal.writeLine('SUCCESS Device reset');
            } else if (loader.transport && loader.transport.setSignals) {
                await loader.transport.setSignals({ dataTerminalReady: false, requestToSend: true });
                await new Promise(resolve => setTimeout(resolve, 100));
                await loader.transport.setSignals({ dataTerminalReady: false, requestToSend: false });
                terminal.writeLine('SUCCESS Device reset');
            } else {
                terminal.writeLine('ERROR Reset method not available');
            }
        } catch (error) {
            terminal.writeLine('ERROR Reset failed: ' + error.message);
        }
    });

    // File handling
    const fileInput = document.getElementById('file-input');
    const fileDrop = document.getElementById('file-drop');

    fileDrop.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    fileDrop.addEventListener('dragover', (e) => {
        e.preventDefault();
        fileDrop.classList.add('dragover');
    });

    fileDrop.addEventListener('dragleave', () => {
        fileDrop.classList.remove('dragover');
    });

    fileDrop.addEventListener('drop', (e) => {
        e.preventDefault();
        fileDrop.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
    });

    // Terminal controls
    document.getElementById('clear-terminal').addEventListener('click', () => {
        terminal.clean();
    });

    document.getElementById('copy-terminal').addEventListener('click', () => {
        const text = logData.join('\n');
        navigator.clipboard.writeText(text).then(() => {
            terminal.writeLine('INFO Log copied to clipboard');
        });
    });

    document.getElementById('download-log').addEventListener('click', () => {
        const text = logData.join('\n');
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `esp-flasher-log-${new Date().toISOString().split('T')[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    });
}

// Start initialization
init().catch(error => {
    console.error('Initialization failed:', error);
});
</script>
</body>
</html>
